// Single Wheel Shooter Subsystem controls 
// copied from 2023 Swerve-Clamp.java  10/31/2023 Rod N
// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

 // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
 // REV smartMax code copied from Alternate Encoder example  %rod
import com.revrobotics.RelativeEncoder;
import com.revrobotics.SparkMaxPIDController;
import com.revrobotics.CANSparkMax;
import com.revrobotics.CANSparkMaxLowLevel.MotorType;  
import edu.wpi.first.wpilibj.DigitalInput;
/**
 *
 */
public class Shooter extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private static final int ShooterID= 8; 
    private static final int FeederID= 9; 
  
    private CANSparkMax shooter_motor;
    private CANSparkMax feeder_motor;
    private SparkMaxPIDController pidShooter;
    private RelativeEncoder shooter_encoder;
    private DigitalInput feedPhotoEye;
    public double kP, kI, kD, kIz, kFF, kMaxOutput, kMinOutput, maxRPM, maxVel, minVel, maxAcc, allowedErr;
    /**
    *
    */
    public Shooter() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
         // initialize SPARK MAX with CAN ID
   
    //Feeder Neo550      
    feeder_motor = new CANSparkMax(FeederID, MotorType.kBrushless);
    feeder_motor.restoreFactoryDefaults();
    feeder_motor.setSmartCurrentLimit( 10, 15);
    // Shooter Neo500
    shooter_motor = new CANSparkMax(ShooterID, MotorType.kBrushless);
    shooter_motor.restoreFactoryDefaults();
    shooter_motor.setSmartCurrentLimit( 30, 40);
    pidShooter = shooter_motor.getPIDController();
    shooter_encoder = shooter_motor.getEncoder();
    feedPhotoEye = new DigitalInput(0);

    // set PID coefficients  Not Used yet...................
    pidShooter.setP(0.00015); // proportional for Neo 550 arm
    pidShooter.setI(0.0000);
    pidShooter.setD(0);
    pidShooter.setIZone(0);
    pidShooter.setFF(0);
    pidShooter.setOutputRange(-1, 1);

    // set Motion Magic
    int smartMotionSlot = 0; // ????????????????????????????????
    pidShooter.setSmartMotionMaxVelocity(10000, smartMotionSlot);
    pidShooter.setSmartMotionMinOutputVelocity(0, smartMotionSlot);
    pidShooter.setSmartMotionMaxAccel(10000, smartMotionSlot);
    pidShooter.setSmartMotionAllowedClosedLoopError(allowedErr, smartMotionSlot); // ?????????????

     // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run
        SmartDashboard.putNumber("Shooter Drive", shooter_motor.getAppliedOutput());
        SmartDashboard.putNumber("Shooter Current", shooter_motor.getOutputCurrent());
        SmartDashboard.putNumber("Feeder Current", feeder_motor.getOutputCurrent());
        SmartDashboard.putBoolean("Feeder P/E", feedPhotoEye.get());

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void position(double ShooterPose)
    {
     // magic elbow control
     pidShooter.setReference(ShooterPose, CANSparkMax.ControlType.kSmartMotion);
 
  
    }
    public void driveShooter(double shooterSpeed )
    {
        shooter_motor.set(shooterSpeed);
    }

    public void driveFeeder(double feederSpeed )
    {
        feeder_motor.set(feederSpeed);
    }
    public boolean photoeye( )
    {
        return(feedPhotoEye.get());
    }

       
}
    

